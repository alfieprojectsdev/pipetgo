# Database Index Optimization Recommendations

**Created:** 2025-11-08
**Status:** Analysis Complete - Ready for Implementation
**Priority:** MEDIUM (performance optimization for production scale)
**Effort:** 10 minutes

---

## üìä Current State

**Prisma Schema:** `prisma/schema.prisma`

**Existing Indexes (Auto-generated by Prisma):**
- Primary keys (`@id` fields)
- Unique constraints (`@unique` fields)
- Foreign key fields (for relations)

**Missing:** Composite indexes for multi-column queries

---

## üîç Query Pattern Analysis

### Order Table Query Patterns

Based on API route analysis:

1. **Client Dashboard** (`src/app/api/orders/route.ts:132`)
   ```typescript
   whereClause.clientId = session.user.id
   if (status) whereClause.status = status
   ```
   **Query:** `WHERE clientId = ? AND status = ?`

2. **Lab Admin Dashboard** (`src/app/api/orders/route.ts:138-139`)
   ```typescript
   whereClause.labId = lab.id
   if (status) whereClause.status = status
   ```
   **Query:** `WHERE labId = ? AND status = ?`

3. **Quote Provision** (`src/app/api/orders/[id]/quote/route.ts:42-46`)
   ```typescript
   where: {
     id: params.id,
     lab: { ownerId: session.user.id }
   }
   ```
   **Query:** `WHERE id = ? AND lab.ownerId = ?` (via join)

---

## ‚úÖ Recommended Indexes

### 1. Order Table - Client Queries

**Recommended Index:**
```prisma
model Order {
  // ... existing fields ...

  @@index([clientId, status, createdAt(sort: Desc)])
  @@map("orders")
}
```

**Rationale:**
- `clientId` FIRST (most restrictive - each client has limited orders)
- `status` SECOND (filter for QUOTE_REQUESTED, PENDING, etc.)
- `createdAt DESC` THIRD (for sorting newest first)

**Cardinality Analysis:**
- `clientId`: ~100 clients (Stage 1) ‚Üí ~1000 clients (Stage 2)
- `status`: 9 possible values (enum)
- `clientId` is MORE restrictive than `status` ‚úÖ

---

### 2. Order Table - Lab Admin Queries

**Recommended Index:**
```prisma
model Order {
  // ... existing fields ...

  @@index([labId, status, createdAt(sort: Desc)])
  @@map("orders")
}
```

**Rationale:**
- `labId` FIRST (most restrictive - each lab has limited orders)
- `status` SECOND (filter for incoming quotes, acknowledged, etc.)
- `createdAt DESC` THIRD (for sorting newest first)

**Cardinality Analysis:**
- `labId`: ~20 labs (Stage 1) ‚Üí ~500 labs (Stage 2)
- `status`: 9 possible values (enum)
- `labId` is MORE restrictive than `status` ‚úÖ

---

### 3. LabService Table - Service Discovery

**Recommended Index:**
```prisma
model LabService {
  // ... existing fields ...

  @@index([active, category, labId])
  @@map("lab_services")
}
```

**Rationale:**
- `active` FIRST (most queries filter active = true)
- `category` SECOND (browsing by service category)
- `labId` THIRD (for lab-specific filtering)

**Query Pattern:**
```typescript
// Future: Service discovery
prisma.labService.findMany({
  where: {
    active: true,
    category: 'chemical-analysis'
  }
})
```

---

### 4. Attachment Table - Order Attachments

**Recommended Index:**
```prisma
model Attachment {
  // ... existing fields ...

  @@index([orderId, attachmentType, createdAt(sort: Desc)])
  @@map("attachments")
}
```

**Rationale:**
- `orderId` FIRST (most restrictive - fetching attachments for specific order)
- `attachmentType` SECOND (filter for 'specification' vs 'result')
- `createdAt DESC` THIRD (for sorting newest first)

---

## ‚ö†Ô∏è Index Order Anti-Patterns (AVOID)

### ‚ùå WRONG: Status Before clientId
```prisma
@@index([status, clientId])  // ‚ùå BAD
```

**Why Wrong:**
- `status` has only 9 values ‚Üí Low selectivity
- Database scans many rows with same status first
- THEN filters by clientId

**Performance:**
- Query: `WHERE status = 'PENDING' AND clientId = 'user123'`
- Scans ALL pending orders (~1000s) before filtering by client
- Slow at scale

### ‚úÖ CORRECT: clientId Before Status
```prisma
@@index([clientId, status])  // ‚úÖ GOOD
```

**Why Correct:**
- `clientId` narrows to ~50 orders per client
- THEN filters by status within that small set
- Fast at any scale

**Performance:**
- Query: `WHERE clientId = 'user123' AND status = 'PENDING'`
- Scans only ~50 orders for this client
- Then filters by status (trivial)
- Fast

---

## üöÄ Implementation Steps

### 1. Update Prisma Schema

Add recommended indexes to `prisma/schema.prisma`:

```prisma
model Order {
  // ... existing fields ...

  @@index([clientId, status, createdAt(sort: Desc)])
  @@index([labId, status, createdAt(sort: Desc)])
  @@map("orders")
}

model LabService {
  // ... existing fields ...

  @@index([active, category, labId])
  @@map("lab_services")
}

model Attachment {
  // ... existing fields ...

  @@index([orderId, attachmentType, createdAt(sort: Desc)])
  @@map("attachments")
}
```

### 2. Generate Migration

```bash
# Development
npx prisma migrate dev --name add_composite_indexes

# Production
npx prisma migrate deploy
```

### 3. Verify Indexes Created

```bash
# Check indexes in database
npx prisma db execute --stdin <<EOF
SELECT
  tablename,
  indexname,
  indexdef
FROM
  pg_indexes
WHERE
  schemaname = 'public'
ORDER BY
  tablename,
  indexname;
EOF
```

---

## üìä Expected Performance Improvement

### Before Indexes (Sequential Scan)
```
Query: WHERE clientId = 'user123' AND status = 'PENDING'
Execution Time: 500ms (scans all 10,000 orders)
```

### After Indexes (Index Scan)
```
Query: WHERE clientId = 'user123' AND status = 'PENDING'
Execution Time: 5ms (index scan ~50 orders)
```

**Improvement:** ~100x faster for filtered queries

---

## ‚è±Ô∏è When to Apply

**Priority:** MEDIUM

**Timing:**
- ‚úÖ Safe to apply in Stage 1 (no breaking changes)
- ‚úÖ Will improve performance as data grows
- ‚úÖ Minimal overhead (indexes auto-maintained)

**Recommendation:** Apply before significant user load (>1000 orders)

---

## üîç Monitoring

### Query Performance Testing

After applying indexes:

```bash
# Use EXPLAIN ANALYZE to verify index usage
npx prisma db execute --stdin <<EOF
EXPLAIN ANALYZE
SELECT * FROM orders
WHERE "clientId" = 'user123'
  AND status = 'PENDING'
ORDER BY "createdAt" DESC;
EOF
```

**Look for:**
- ‚úÖ "Index Scan" (good - using index)
- ‚ùå "Sequential Scan" (bad - not using index)

---

## üìö Reference

**Pattern Source:** `/home/user/pipetgo/docs/WEB_CLAUDE_INSTRUCTIONS.md`
**Rule:** Most restrictive column FIRST in multi-column indexes

**Further Reading:**
- Postgres Index Types: https://www.postgresql.org/docs/current/indexes-types.html
- Prisma Indexes: https://www.prisma.io/docs/concepts/components/prisma-schema/indexes

---

**Estimated Impact:** High (100x faster queries at scale)
**Risk:** LOW (non-breaking change, auto-maintained)
**Effort:** 10 minutes
